#region Copyright (C) 2005-2011 Team MediaPortal

// Copyright (C) 2005-2011 Team MediaPortal
// http://www.team-mediaportal.com
// 
// MediaPortal is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
// 
// MediaPortal is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with MediaPortal. If not, see <http://www.gnu.org/licenses/>.

#endregion

using System;
using System.Collections.Generic;
using Gentle.Framework;
using TvLibrary.Log;

namespace TvDatabase
{
  /// <summary>
  /// Instances of this class represent the properties and methods of a row in the table <b>Program</b>.
  /// </summary>
  [TableName("Program")]
  public class Program : Persistent
  {
    #region Members

    private bool isChanged;
    [TableColumn("idProgram", NotNull = true), PrimaryKey(AutoGenerated = true)] private int idProgram;
    [TableColumn("idChannel", NotNull = true), ForeignKey("Channel", "idChannel")] private int idChannel;
    [TableColumn("startTime", NotNull = true)] private DateTime startTime;
    [TableColumn("endTime", NotNull = true)] private DateTime endTime;
    [TableColumn("title", NotNull = true)] private string title;
    [TableColumn("description", NotNull = true)] private string description;
    [TableColumn("genre", NotNull = true)] private string genre;
    [TableColumn("state", NotNull = true)] private int state;
    [TableColumn("originalAirDate", NotNull = true)] private DateTime originalAirDate;
    [TableColumn("seriesNum", NotNull = true)] private string seriesNum;
    [TableColumn("episodeNum", NotNull = true)] private string episodeNum;
    [TableColumn("episodePart", NotNull = true)] private string episodePart;
    [TableColumn("episodeName", NotNull = true)] private string episodeName;
    [TableColumn("starRating", NotNull = true)] private int starRating;
    [TableColumn("classification", NotNull = true)] private string classification;
    [TableColumn("parentalRating", NotNull = true)] private int parentalRating;

    #endregion

    #region public enum

    [Flags]
    public enum ProgramState
    {
      None = 0,
      Notify = 1,
      RecordOnce = 2,
      RecordSeries = 4,
      RecordManual = 8,
      Conflict = 16,
      RecordOncePending = 32, // used to indicate recording icon on tvguide, even though it hasnt begun yet.
      RecordSeriesPending = 64, // used to indicate recording icon on tvguide, even though it hasnt begun yet.
      PartialRecordSeriesPending = 128
      // used to indicate partial recording icon on tvguide, even though it hasnt begun yet.
    }

    #endregion

    #region Constructors

    /// <summary> 
    /// Create a new object by specifying all fields (except the auto-generated primary key field). 
    /// </summary> 
    public Program(int idChannel, DateTime startTime, DateTime endTime, string title, string description, string genre,
                   ProgramState state, DateTime originalAirDate, string seriesNum, string episodeNum, string episodeName,
                   string episodePart, int starRating,
                   string classification, int parentalRating)
    {
      isChanged = true;
      this.idChannel = idChannel;
      this.startTime = startTime;
      this.endTime = endTime;
      this.title = title;
      this.description = description;
      this.genre = genre;
      this.state = (int)state;
      this.originalAirDate = originalAirDate;
      this.seriesNum = seriesNum;
      this.episodeNum = episodeNum;
      this.episodeName = episodeName;
      this.episodePart = episodePart;
      this.starRating = starRating;
      this.classification = classification;
      this.parentalRating = parentalRating;
    }

    /// <summary> 
    /// Create an object from an existing row of data. This will be used by Gentle to 
    /// construct objects from retrieved rows. 
    /// </summary> 
    public Program(int idProgram, int idChannel, DateTime startTime, DateTime endTime, string title, string description,
                   string genre, ProgramState state, DateTime originalAirDate, string seriesNum, string episodeNum,
                   string episodeName, string episodePart,
                   int starRating, string classification, int parentalRating)
    {
      this.idProgram = idProgram;
      this.idChannel = idChannel;
      this.startTime = startTime;
      this.endTime = endTime;
      this.title = title;
      this.description = description;
      this.genre = genre;
      this.state = (int)state;
      this.originalAirDate = originalAirDate;
      this.seriesNum = seriesNum;
      this.episodeNum = episodeNum;
      this.episodeName = episodeName;
      this.episodePart = episodePart;
      this.starRating = starRating;
      this.classification = classification;
      this.parentalRating = parentalRating;
    }

    #endregion

    #region Public Properties

    /// <summary>
    /// Indicates whether the entity is changed and requires saving or not.
    /// </summary>
    public bool IsChanged
    {
      get { return isChanged; }
    }

    /// <summary>
    /// Property relating to database column idProgram
    /// </summary>
    public int IdProgram
    {
      get { return idProgram; }
    }

    /// <summary>
    /// Property relating to database column idChannel
    /// </summary>
    public int IdChannel
    {
      get { return idChannel; }
      set
      {
        isChanged |= idChannel != value;
        idChannel = value;
      }
    }

    /// <summary>
    /// Property relating to database column startTime
    /// </summary>
    public DateTime StartTime
    {
      get { return startTime; }
      set
      {
        isChanged |= startTime != value;
        startTime = value;
      }
    }

    /// <summary>
    /// Property relating to database column endTime
    /// </summary>
    public DateTime EndTime
    {
      get { return endTime; }
      set
      {
        isChanged |= endTime != value;
        endTime = value;
      }
    }

    /// <summary>
    /// Property relating to database column title
    /// </summary>
    public string Title
    {
      get { return title; }
      set
      {
        isChanged |= title != value;
        title = value;
      }
    }

    /// <summary>
    /// Property relating to database column description
    /// </summary>
    public string Description
    {
      get { return description; }
      set
      {
        isChanged |= description != value;
        description = value;
      }
    }

    /// <summary>
    /// Property relating to database column genre
    /// </summary>
    public string Genre
    {
      get { return genre; }
      set
      {
        isChanged |= genre != value;
        genre = value;
      }
    }

    /// <summary>
    /// Property relating to database column notify
    /// </summary>
    public bool Notify
    {
      get { return ((state & (int)ProgramState.Notify) == (int)ProgramState.Notify); }
      set
      {
        ProgramState newState = (ProgramState)state;
        if (!value && (state & (int)ProgramState.Notify) == (int)ProgramState.Notify)
          // remove the notify bit flag if present
        {
          newState ^= ProgramState.Notify;
        }
        if (value) //add the notify bit flag
        {
          newState |= ProgramState.Notify;
        }

        isChanged |= (int)state != (int)newState;
        state = (int)newState;
      }
    }

    /// <summary>
    /// Property relating to database column conflict
    /// </summary>
    public bool HasConflict
    {
      get { return ((state & (int)ProgramState.Conflict) == (int)ProgramState.Conflict); }
      set
      {
        ProgramState newState = (ProgramState)state;
        if (!value && (state & (int)ProgramState.Conflict) == (int)ProgramState.Conflict)
          // remove the Conflict bit flag if present
        {
          newState ^= ProgramState.Conflict;
        }
        if (value) //add the Conflict bit flag
        {
          newState |= ProgramState.Conflict;
        }

        isChanged |= (int)state != (int)newState;
        state = (int)newState;
      }
    }

    /// <summary>
    /// Property relating to database column IsRecording
    /// </summary>
    public bool IsRecording
    { // This should reflect whether program is actually recording right now
      get { return ( IsRecordingSeries || IsRecordingManual || IsRecordingOnce); }
    }

    /// <summary>
    /// Property relating to database column IsRecordingOnce
    /// </summary>
    public bool IsRecordingOnce
    {
      get { return ((state & (int)ProgramState.RecordOnce) == (int)ProgramState.RecordOnce); }
      set
      {
        ProgramState newState = (ProgramState)state;
        if (!value && (state & (int)ProgramState.RecordOnce) == (int)ProgramState.RecordOnce)
          // remove the Record bit flag if present                        
        {
          newState ^= ProgramState.RecordOnce;
        }
        if (value) //add the Record bit flag
        {
          newState |= ProgramState.RecordOnce;
        }

        isChanged |= (int)state != (int)newState;
        state = (int)newState;
      }
    }


    /// <summary>
    /// Property relating to database column IsRecordingSeriesPending
    /// </summary>
    public bool IsRecordingSeriesPending
    {
      get { return ((state & (int)ProgramState.RecordSeriesPending) == (int)ProgramState.RecordSeriesPending); }
      set
      {
        ProgramState newState = (ProgramState)state;
        if (!value && (state & (int)ProgramState.RecordSeriesPending) == (int)ProgramState.RecordSeriesPending)
          // remove the Record bit flag if present                
        {
          newState ^= ProgramState.RecordSeriesPending;
        }
        if (value) //add the Record bit flag
        {
          newState |= ProgramState.RecordSeriesPending;
        }

        isChanged |= (int)state != (int)newState;
        state = (int)newState;
      }
    }

    /// <summary>
    /// Property relating to database column IsRecordingSeriesPending
    /// </summary>
    public bool IsPartialRecordingSeriesPending
    {
      get { return ((state & (int)ProgramState.PartialRecordSeriesPending) == (int)ProgramState.PartialRecordSeriesPending); }
      set
      {
        ProgramState newState = (ProgramState)state;
        if (value) //add the Record bit flag
        {
          newState |= ProgramState.PartialRecordSeriesPending;
        }
        else
        {
          newState &= ~ProgramState.PartialRecordSeriesPending;
        }
        isChanged |= (int)state != (int)newState;
        state = (int)newState;
      }
    }

    /// <summary>
    /// Property relating to database column IsRecordingOncePending
    /// </summary>
    public bool IsRecordingOncePending
    {
      get { return ((state & (int)ProgramState.RecordOncePending) == (int)ProgramState.RecordOncePending); }
      set
      {
        ProgramState newState = (ProgramState)state;
        if (!value && (state & (int)ProgramState.RecordOncePending) == (int)ProgramState.RecordOncePending)
          // remove the Record bit flag if present        
        {
          newState ^= ProgramState.RecordOncePending;
        }
        if (value) //add the Record bit flag
        {
          newState |= ProgramState.RecordOncePending;
        }

        isChanged |= (int)state != (int)newState;
        state = (int)newState;
      }
    }

    /// <summary>
    /// Property relating to database column IsRecordingManual
    /// </summary>
    public bool IsRecordingManual
    {
      get { return ((state & (int)ProgramState.RecordManual) == (int)ProgramState.RecordManual); }
      set
      {
        ProgramState newState = (ProgramState)state;
        if (!value && (state & (int)ProgramState.RecordManual) == (int)ProgramState.RecordManual)
          // remove the Record bit flag if present
        {
          newState ^= ProgramState.RecordManual;
        }
        if (value) //add the Record bit flag
        {
          newState |= ProgramState.RecordManual;
        }

        isChanged |= (int)state != (int)newState;
        state = (int)newState;
      }
    }


    /// <summary>
    /// Property relating to database column isRecording
    /// </summary>
    public bool IsRecordingSeries
    {
      get { return ((state & (int)ProgramState.RecordSeries) == (int)ProgramState.RecordSeries); }
      set
      {
        ProgramState newState = (ProgramState)state;
        if (!value && (state & (int)ProgramState.RecordSeries) == (int)ProgramState.RecordSeries)
          // remove the RecordSeries bit flag if present
        {
          newState ^= ProgramState.RecordSeries;
        }
        if (value) //add the RecordSeries bit flag
        {
          newState |= ProgramState.RecordSeries;
        }

        isChanged |= (int)state != (int)newState;
        state = (int)newState;
      }
    }


    /// <summary>
    /// The original air date of the program
    /// </summary>
    public DateTime OriginalAirDate
    {
      get { return originalAirDate; }
      set
      {
        isChanged |= originalAirDate != value;
        originalAirDate = value;
      }
    }

    /// <summary>
    /// The programs series id
    /// </summary>
    public string SeriesNum
    {
      get { return seriesNum; }
      set
      {
        isChanged |= seriesNum != value;
        seriesNum = value;
      }
    }

    /// <summary>
    /// The programs episode number from the distributor
    /// </summary>
    public string EpisodeNum
    {
      get { return episodeNum; }
      set
      {
        isChanged |= episodeNum != value;
        episodeNum = value;
      }
    }

    /// <summary>
    /// The programs episode title from the distributor
    /// </summary>
    public string EpisodeName
    {
      get { return episodeName; }
      set
      {
        isChanged |= episodeName != value;
        episodeName = value;
      }
    }

    /// <summary>
    /// The programs episode part from the distributor
    /// </summary>
    public string EpisodePart
    {
      get { return episodePart; }
      set
      {
        isChanged |= episodePart != value;
        episodePart = value;
      }
    }

    /// <summary>
    /// Property relating to database column seriesNum, episodeNum and episodePart (readonly)
    /// </summary>
    public string EpisodeNumber
    {
      get { return TvDatabase.EpisodeFormatter.GetEpisodeNumber(seriesNum, episodeNum, episodePart); }
    }

    /// <summary>
    /// A rating for a movie (EPG standard is 0/5 stars = 10)
    /// </summary>
    public int StarRating
    {
      get { return starRating; }
      set
      {
        isChanged |= starRating != value;
        starRating = value;
      }
    }

    /// <summary>
    /// A rating for a program (e.g. USK, FSK, etc)
    /// </summary>
    public string Classification
    {
      get { return classification; }
      set
      {
        isChanged |= classification != value;
        classification = value;
      }
    }

    /// <summary>
    /// A parental guidance rating for a program (the nr gives the min. age suggested to watch this program)
    /// </summary>
    public int ParentalRating
    {
      get { return parentalRating; }
      set
      {
        isChanged |= parentalRating != value;
        parentalRating = value;
      }
    }

    #endregion

    #region Storage and Retrieval

    #region SQL constraint helpers

    private static void AddTimeRangeConstraint(SqlBuilder sb, string startField, string endField, string startParam,
                                               string endParam, bool crossMidnight)
    {
      string provider = ProviderFactory.GetDefaultProvider().Name.ToLowerInvariant();
      string baseConstraint;
      switch (provider)
      {
        case "mysql":
          baseConstraint =
            string.Format("({0} < DATE_ADD(ADDDATE(DATE({0}), {4}{{0}}), INTERVAL TIME(?{3}) HOUR_SECOND)" +
                          " AND {1} > DATE_ADD(ADDDATE(DATE({0}), 0{{0}}), INTERVAL TIME(?{2}) HOUR_SECOND))",
                          startField, endField, startParam, endParam, crossMidnight ? 1 : 0);
          break;
        case "sqlserver":
          baseConstraint = string.Format("({0} < DateAdd(Day, DateDiff(Day, @{2}, {0}){{0}}, @{3})" +
                                         "AND {1} > DateAdd(Day, DateDiff(Day, @{2}, {0}){{0}}, @{2}))",
                                         startField, endField, startParam, endParam);
          break;
        default:
          return;
      }
      sb.AddConstraint("(" + string.Format(baseConstraint, "") +
                       " OR " + string.Format(baseConstraint, "+1") +
                       " OR " + string.Format(baseConstraint, "-1") + ")");
    }

    private static void AddWeekdayConstraint(SqlBuilder sb, string timeField, string days)
    {
      string provider = ProviderFactory.GetDefaultProvider().Name.ToLowerInvariant();
      switch (provider)
      {
        case "mysql":
          sb.AddConstraint(string.Format("DAYOFWEEK({0}) in ({1})", timeField, days));
          break;
        case "sqlserver":
          // DATEPART(dw, {0})+@@DATEFIRST-7 makes sure result is the same regardless of regional settings
          sb.AddConstraint(string.Format("(DATEPART(dw, {0})+@@DATEFIRST-7) in ({1})", timeField, days));
          break;
      }
    }

    private static void AddWeekendsConstraint(SqlBuilder sb, string timeField)
    {
      AddWeekdayConstraint(sb, timeField, WeekEndTool.SqlWeekendDays);
    }

    private static void AddWorkingDaysConstraint(SqlBuilder sb, string timeField)
    {
      AddWeekdayConstraint(sb, timeField, WeekEndTool.SqlWorkingDays);
    }

    #endregion

    /// <summary>
    /// Static method to retrieve all instances that are stored in the database in one call
    /// </summary>
    public static IList<Program> ListAll()
    {
      return Broker.RetrieveList<Program>();
    }

    /// <summary>
    /// Retrieves an entity given it's id.
    /// </summary>
    public static Program Retrieve(int id)
    {
      // Return null if id is smaller than seed and/or increment for autokey
      if (id < 1)
      {
        return null;
      }
      Key key = new Key(typeof (Program), true, "idProgram", id);
      return Broker.RetrieveInstance<Program>(key);
    }

    /// <summary>
    /// Retreives the first found instance of a Program given its Title,Start and End Times 
    /// </summary>
    /// <param name="title">Title we wanna look for</param>
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <returns></returns>
    public static Program RetrieveByTitleAndTimes(string title, DateTime startTime, DateTime endTime)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Program));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "Title", title);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);
      sb.AddConstraint(Operator.Equals, "endTime", endTime);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Program> result = ObjectFactory.GetCollection<Program>(stmt.Execute());
      if (result == null)
      {
        return null;
      }
      if (result.Count == 0)
      {
        return null;
      }
      return result[0];

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    public static Program RetrieveOnce(string title, DateTime startTime, DateTime endTime, int channelId)
    {
      return RetrieveByTitleTimesAndChannel(title, startTime, endTime, channelId);
    }

    public static IList<Program> RetrieveDaily(DateTime startTime, DateTime endTime, int channelId)
    {
      return RetrieveDaily(startTime, endTime, channelId, -1);
    }

    public static IList<Program> RetrieveDaily(DateTime startTime, DateTime endTime, int channelId, int maxDays)
    {
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Program));

      // where foreigntable.foreignkey = ourprimarykey      
      sb.AddConstraint(Operator.GreaterThanOrEquals, "endTime", DateTime.Now /*startTime*/);
      if (maxDays > 0)
      {
        sb.AddConstraint(Operator.LessThan, "startTime", DateTime.Now.AddDays(maxDays));
      }
      sb.AddConstraint(Operator.Equals, "idChannel", channelId);
      sb.AddParameter("pStartTime", typeof (DateTime));
      sb.AddParameter("pEndTime", typeof (DateTime));
      AddTimeRangeConstraint(sb, "startTime", "endTime", "pStartTime", "pEndTime", (endTime.Day != startTime.Day));
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);
      stmt.SetParameter("pStartTime", startTime);
      stmt.SetParameter("pEndTime", endTime);
      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Program>(stmt.Execute());
    }

    public static IList<Program> RetrieveWeeklyEveryTimeOnThisChannel(DateTime startTime, DateTime endTime, string title,
                                                                      int channelId)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Program));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "Title", title);
      sb.AddConstraint(Operator.Equals, "idChannel", channelId);
      sb.AddConstraint(Operator.GreaterThanOrEquals, "startTime", DateTime.Now);
      sb.AddConstraint(Operator.LessThanOrEquals, "endTime", DateTime.MaxValue);

      AddWeekdayConstraint(sb, "startTime", ((int)startTime.DayOfWeek + 1).ToString());
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Program>(stmt.Execute());
    }

    public static IList<Program> RetrieveEveryTimeOnEveryChannel(string title)
    {
      return RetrieveByTitleAndTimesInterval(title, DateTime.Now, DateTime.MaxValue);
    }

    public static IList<Program> RetrieveEveryTimeOnEveryChannel(string title, int maxDays)
    {
      return RetrieveByTitleAndTimesInterval(title, DateTime.Now, DateTime.Now.AddDays(maxDays));
    }

    public static IList<Program> RetrieveEveryTimeOnThisChannel(string title, int channelId)
    {
      return RetrieveEveryTimeOnThisChannel(title, channelId, -1);
    }

    public static IList<Program> RetrieveEveryTimeOnThisChannel(string title, int channelId, int maxDays)
    {
      DateTime startTime = DateTime.Now;
      DateTime endTime = maxDays > 0 ? startTime.AddDays(maxDays) : DateTime.MaxValue;

      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Program));
      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "Title", title);
      sb.AddConstraint(Operator.GreaterThanOrEquals, "endTime", startTime);
      sb.AddConstraint(Operator.LessThan, "endTime", endTime);
      sb.AddConstraint(Operator.Equals, "idChannel", channelId);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Program>(stmt.Execute());
    }

    public static IList<Program> RetrieveWeekends(DateTime startTime, DateTime endTime, int channelId)
    {
      return RetrieveWeekends(startTime, endTime, channelId, -1);
    }

    public static IList<Program> RetrieveWeekends(DateTime startTime, DateTime endTime, int channelId, int maxDays)
    {
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Program));

      // where foreigntable.foreignkey = ourprimarykey      
      sb.AddConstraint(Operator.GreaterThanOrEquals, "endTime", DateTime.Now /*startTime*/);
      if (maxDays > 0)
      {
        sb.AddConstraint(Operator.LessThan, "startTime", DateTime.Now.AddDays(maxDays));
      }
      sb.AddConstraint(Operator.Equals, "idChannel", channelId);
      sb.AddParameter("pStartTime", typeof (DateTime));
      sb.AddParameter("pEndTime", typeof (DateTime));
      AddTimeRangeConstraint(sb, "startTime", "endTime", "pStartTime", "pEndTime", (endTime.Day != startTime.Day));
      AddWeekendsConstraint(sb, "startTime");
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);
      stmt.SetParameter("pStartTime", startTime);
      stmt.SetParameter("pEndTime", endTime);
      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Program>(stmt.Execute());
    }

    public static IList<Program> RetrieveWeekly(DateTime startTime, DateTime endTime, int channelId)
    {
      return RetrieveWeekly(startTime, endTime, channelId, -1);
    }

    public static IList<Program> RetrieveWeekly(DateTime startTime, DateTime endTime, int channelId, int maxDays)
    {
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Program));

      // where foreigntable.foreignkey = ourprimarykey      
      sb.AddConstraint(Operator.GreaterThanOrEquals, "endTime", DateTime.Now /*startTime*/);
      if (maxDays > 0)
      {
        sb.AddConstraint(Operator.LessThan, "startTime", DateTime.Now.AddDays(maxDays));
      }
      sb.AddConstraint(Operator.Equals, "idChannel", channelId);
      sb.AddParameter("pStartTime", typeof (DateTime));
      sb.AddParameter("pEndTime", typeof (DateTime));
      AddTimeRangeConstraint(sb, "startTime", "endTime", "pStartTime", "pEndTime", (endTime.Day != startTime.Day)); //
      AddWeekdayConstraint(sb, "startTime", ((int)startTime.DayOfWeek + 1).ToString());
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);
      stmt.SetParameter("pStartTime", startTime);
      stmt.SetParameter("pEndTime", endTime);
      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Program>(stmt.Execute());
    }

    public static IList<Program> RetrieveWorkingDays(DateTime startTime, DateTime endTime, int channelId)
    {
      return RetrieveWorkingDays(startTime, endTime, channelId, -1);
    }

    public static IList<Program> RetrieveWorkingDays(DateTime startTime, DateTime endTime, int channelId, int maxDays)
    {
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Program));

      // where foreigntable.foreignkey = ourprimarykey      
      sb.AddConstraint(Operator.GreaterThanOrEquals, "endTime", DateTime.Now /*startTime*/);
      if (maxDays > 0)
      {
        sb.AddConstraint(Operator.LessThan, "startTime", DateTime.Now.AddDays(maxDays));
      }
      sb.AddConstraint(Operator.Equals, "idChannel", channelId);
      sb.AddParameter("pStartTime", typeof (DateTime));
      sb.AddParameter("pEndTime", typeof (DateTime));
      AddTimeRangeConstraint(sb, "startTime", "endTime", "pStartTime", "pEndTime", (endTime.Day != startTime.Day));
      AddWorkingDaysConstraint(sb, "startTime");
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);
      stmt.SetParameter("pStartTime", startTime);
      stmt.SetParameter("pEndTime", endTime);
      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Program>(stmt.Execute());
    }

    /// <summary>
    /// Retreives the first found instance of a Program given its Title,Start and End Times and referenced channel
    /// </summary>
    /// <param name="title">Title we wanna look for</param>
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <param name="channelId">Referenced Channel id</param>
    /// <returns></returns>
    public static Program RetrieveByTitleTimesAndChannel(string title, DateTime startTime, DateTime endTime,
                                                         int channelId)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Program));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "Title", title);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);
      sb.AddConstraint(Operator.Equals, "endTime", endTime);
      sb.AddConstraint(Operator.Equals, "idChannel", channelId);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Program> result = ObjectFactory.GetCollection<Program>(stmt.Execute());
      if (result == null)
      {
        return null;
      }
      if (result.Count == 0)
      {
        return null;
      }
      return result[0];

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    /// <summary>
    /// Retreives the first found instance of a Program given its Title,Start and End Times and referenced channel
    /// </summary>
    /// <param name="title">Title we wanna look for</param>
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <param name="channelId">Referenced Channel id</param>
    /// <returns></returns>
    public static IList<Program> RetrieveListByTitleTimesAndChannel(string title, DateTime startTime, DateTime endTime,
                                                                    int channelId)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Program));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "Title", title);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);
      sb.AddConstraint(Operator.Equals, "endTime", endTime);
      sb.AddConstraint(Operator.Equals, "idChannel", channelId);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Program>(stmt.Execute());
    }

    public static void ResetPendingState(int idProgram)
    {
      Program prg = Program.Retrieve(idProgram);

      if (prg != null)
      {
        prg.IsRecordingOncePending = false;
        prg.IsRecordingSeriesPending = false;
        prg.IsPartialRecordingSeriesPending = false;
      }
      prg.Persist();
    }

    public static void SetSingleStateSeriesPending(DateTime startTime, int idChannel, string title)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Program));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "Title", title);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);

      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      IList<Program> result = ObjectFactory.GetCollection<Program>(stmt.Execute());

      if (result == null || result.Count == 0)
      {
        return;
      }

      Program prg = result[0];
      prg.IsRecordingOncePending = false;
      prg.IsRecordingSeriesPending = true;
      prg.Persist();
    }

    public static void ResetAllStates()
    {
      string sql = "Update Program set state=0 where state<>0;";
      SqlStatement stmt = new SqlStatement(StatementType.Update, Broker.Provider.GetCommand(), sql);
      stmt.Execute();
      Gentle.Common.CacheManager.ClearQueryResultsByType(typeof(Program));
    }

    public void ClearRecordPendingState()
    {
      state &=
        ~(int)
         (ProgramState.RecordOncePending | ProgramState.RecordSeriesPending | ProgramState.PartialRecordSeriesPending);
    }

    public static IList<Program> RetrieveAllNotifications()
    {
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Program));
      //sb.AddConstraint("state % 2 <> 0"); //odd state numbers are notifications      
      string notify = Convert.ToString((int)ProgramState.Notify);
      sb.AddConstraint("state & " + notify + " = " + notify);

      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set      
      return ObjectFactory.GetCollection<Program>(stmt.Execute());
    }

    /// <summary>
    /// Retreives the first found instance of a Program given its Title
    /// </summary>
    /// <param name="title">Title we wanna look for</param>
    /// <returns></returns>
    public static IList<Program> RetrieveByTitle(string title)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Program));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "Title", title);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      //return (Program)ObjectFactory.GetCollection(typeof(Program), stmt.Execute())[0];
      return ObjectFactory.GetCollection<Program>(stmt.Execute());

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    /// <summary>
    /// Retreives any current running Program given its Title , using pre and post recording times 
    /// </summary>
    /// <param name="title">Title we wanna look for</param>
    /// <param name="preRec">Pre recording value</param>
    /// <param name="postRec">Post recording value</param>
    /// <returns></returns>
    public static IList<Program> RetrieveCurrentRunningByTitle(string title, int preRec, int postRec)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Program));
      sb.AddConstraint(Operator.Equals, "Title", title);
      sb.AddConstraint(Operator.LessThanOrEquals, "startTime", DateTime.Now.AddMinutes(preRec));
      sb.AddConstraint(Operator.GreaterThan, "endTime", DateTime.Now);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Program>(stmt.Execute());

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    /// <summary>
    /// Retreives the programs with a given title and starting between given Start and End Times 
    /// </summary>
    /// <param name="title">Title we wanna look for</param>
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <returns></returns>
    public static IList<Program> RetrieveByTitleAndTimesInterval(string title, DateTime startTime, DateTime endTime)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Program));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "Title", title);
      sb.AddConstraint(Operator.GreaterThanOrEquals, "endTime", startTime);
      sb.AddConstraint(Operator.LessThanOrEquals, "startTime", endTime);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Program>(stmt.Execute());

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    /// <summary>
    /// Retrieves an entity given it's id, using Gentle.Framework.Key class.
    /// This allows retrieval based on multi-column keys.
    /// </summary>
    public static Program Retrieve(Key key)
    {
      return Broker.RetrieveInstance<Program>(key);
    }

    /// <summary>
    /// Persists the entity if it was never persisted or was changed.
    /// </summary>
    public override void Persist()
    {
      if (IsChanged || !IsPersisted)
      {
        try
        {
          base.Persist();
        }
        catch (Exception ex)
        {
          Log.Error("Exception in Program.Persist() with Message {0}", ex.Message);
          return;
        }
        isChanged = false;
      }
    }

    #endregion

    #region Relations

    /// <summary>
    /// Get a list of Favorite referring to the current entity.
    /// </summary>
    public IList<Favorite> ReferringFavorite()
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Favorite));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "idProgram", idProgram);

      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Favorite>(stmt.Execute());

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(Favorite), this );
    }

    /// <summary>
    ///
    /// </summary>
    public Channel ReferencedChannel()
    {
      return Channel.Retrieve(IdChannel);
    }

    #endregion

    public void Delete()
    {
      IList<Favorite> list = ReferringFavorite();
      foreach (Favorite favorite in list)
      {
        favorite.Remove();
      }
      Remove();
    }

    /// <summary>
    /// Checks if the program is running between the specified start and end time/dates, i.e. whether the intervals overlap
    /// </summary>
    /// <param name="tStartTime">Start date and time</param>
    /// <param name="tEndTime">End date and time</param>
    /// <returns>true if program is running between tStartTime-tEndTime</returns>
    public bool RunningAt(DateTime tStartTime, DateTime tEndTime)
    {
      // do NOT use <= >= since end-times are non-including
      return tStartTime < EndTime && tEndTime > StartTime;
    }

    /// <summary>
    /// Checks if the program is running at the specified date/time
    /// </summary>
    /// <param name="tCurTime">date and time</param>
    /// <returns>true if program is running at tCurTime</returns>
    public bool IsRunningAt(DateTime tCurTime)
    {
      bool bRunningAt = false;
      if (tCurTime >= StartTime && tCurTime <= EndTime)
      {
        bRunningAt = true;
      }
      return bRunningAt;
    }

    /// <summary>
    /// Checks if the program ended prior to the specified date/time
    /// </summary>
    /// <param name="tCurTime">date and time</param>
    /// <returns>true if program ended prior to tCurTime</returns>
    public bool EndedBefore(DateTime tCurTime)
    {
      bool bEndedBefore = false;
      if (EndTime <= tCurTime)
      {
        bEndedBefore = true;
      }
      return bEndedBefore;
    }

    public Program Clone()
    {
      Program p = new Program(idProgram, idChannel, StartTime, EndTime, Title, Description, Genre, (ProgramState)state,
                              OriginalAirDate,
                              SeriesNum, EpisodeNum, EpisodeName, EpisodePart, StarRating, Classification,
                              parentalRating);
      return p;
    }

    public override string ToString()
    {
      return String.Format("{0}(ID:{1}) on {2} {3} - {4}", Title, idProgram, IdChannel, StartTime, EndTime);
    }
  }
}