/*
 * Base class for all database analyzers
 * Copyright (C) 2004 Morten Mertner
 * 
 * This library is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU Lesser General Public License 2.1 or later, as
 * published by the Free Software Foundation. See the included License.txt
 * or http://www.gnu.org/copyleft/lesser.html for details.
 *
 * $Id: GentleAnalyzer.cs 1232 2008-03-14 05:36:00Z mm $
 */

using System;
using System.Collections;
using System.Text;
using Gentle.Common;

namespace Gentle.Framework
{
	[Flags]
	public enum ColumnInformation
	{
		// table information
		TableType = 1 << 1,
		TableSize = 1 << 2,
		TableIsNullable = 1 << 3,
		TableIsAutoGenerated = 1 << 4,
		TableSequenceName = 1 << 5,
		TableIsUnique = 1 << 6,
		TableIsPrimaryKey = 1 << 7,
		TableIsForeignKey = 1 << 8,
		TableHasForeignKey = 1 << 9,
		// view information
		IsView = 1 << 10,
		ViewType = 1 << 11,
		ViewSize = 1 << 12,
		ViewIsNullable = 1 << 13,
		ViewIsAutoGenerated = 1 << 14,
		ViewSequenceName = 1 << 15,
		ViewIsUnique = 1 << 16,
		ViewIsPrimaryKey = 1 << 17,
		ViewIsForeignKey = 1 << 18,
		ViewHasForeignKey = 1 << 19,
		// combinations (table + view)
		Type = TableType | ViewType,
		Size = TableSize | ViewSize,
		IsNullable = TableIsNullable | ViewIsNullable,
		IsAutoGenerated = TableIsAutoGenerated | ViewIsAutoGenerated,
		SequenceName = TableSequenceName | ViewSequenceName,
		IsUnique = TableIsUnique | ViewIsUnique,
		IsPrimaryKey = TableIsPrimaryKey | ViewIsPrimaryKey,
		IsForeignKey = TableIsForeignKey | ViewIsForeignKey,
		HasForeignKey = TableHasForeignKey | ViewHasForeignKey,
		// standard selections
		ciBasic = TableSize | TableType,
		ciExtra = TableIsNullable | TableIsUnique,
		ciKey = TableIsPrimaryKey | TableIsAutoGenerated | TableSequenceName,
		ciRelationOut = TableIsForeignKey,
		ciRelationIn = TableHasForeignKey,
		ciViewBasic = IsView | ViewType | ViewSize | ViewIsNullable,
		ciLocal = ciBasic | ciExtra | ciKey | ciRelationOut | ciViewBasic,
		ciAll = ciLocal | ciRelationIn
	}

	/// <summary>
	/// Base class for all database analyzers.
	/// </summary>
	public abstract class GentleAnalyzer : IDatabaseAnalyzer
	{
		protected IGentleProvider provider;
		protected PersistenceBroker broker;
		private AnalyzerLevel level;

		// list of generated maps indexed by table name
		protected Hashtable maps;
		// boolean to indicate if we've scanned all tables
		protected bool done;

		/// <summary>
		/// Constructor for the GentleAnalyzer base class.
		/// </summary>
		/// <param name="provider"></param>
		protected GentleAnalyzer( IGentleProvider provider )
		{
			this.provider = provider;
			if( maps == null )
			{
				maps = new Hashtable();
				done = false;
			}
			// make sure we use our own PB to avoid using the DefaultProvider when analyzing the database
			broker = new PersistenceBroker( provider );
			// this.broker = new PersistenceBroker( provider.Name, provider.ConnectionString );
			// set the default analyzer level
			level = GentleSettings.AnalyzerLevel;
		}

		/// <summary>
		/// This property should be defined in subclasses to indicate which information fields
		/// the Analyzer class is able to obtain. 
		/// </summary>
		public abstract ColumnInformation AnalyzerCapability { get; }

		/// <summary>
		/// Use this method to check if the provider supports obtaining the specified information.
		/// </summary>
		public bool HasCapability( ColumnInformation ci )
		{
			return (ci & AnalyzerCapability) != 0;
		}

		/// <summary>
		/// Use this method to get or set the analyzer level used. Note that changing this setting too
		/// late it might have no effect (if tables have already been analyzed).
		/// </summary>
		public AnalyzerLevel Level
		{
			get { return level; }
			set { level = value; }
		}

		/// <summary>
		/// This property is a Hashtable of TableMap instances containing metadata on
		/// tables obtained from the database. Client programs can iterate through this
		/// list and use the TableMap instances to generate Gentle business objects (be
		/// sure to set the AnalyzerLevel to Full in the configuration file if used for
		/// this purpose).
		/// </summary>
		public Hashtable TableMaps
		{
			get
			{
				if( level == AnalyzerLevel.Full && ! done )
				{
					Analyze( null );
					done = true;
				}
				return maps;
			}
		}

		/// <summary>
		/// Get an existing TableMap from the underlying store of the TableMaps property. This 
		/// method ensures that tables are looked up case insensitively and without triggering
		/// any database scanning (which could otherwise lead to loops).
		/// </summary>
		/// <param name="tableName">The name of the table whose map to retrieve.</param>
		/// <returns>The corresponding TableMap instance or null if none was found.</returns>
		public virtual TableMap GetTableMap( string tableName )
		{
			if( tableName == null )
			{
				return null;
			}
			tableName = tableName.ToLower();
			return maps.ContainsKey( tableName ) ? maps[ tableName ] as TableMap : null;
		}

		/// <summary>
		/// This method obtains metadata by analyzing the database. If no table name
		/// is specified all available tables will be processed.
		/// </summary>
		/// <param name="tableName">The table name to analyze or null for all tables</param>
		public abstract void Analyze( string tableName );

		/// <summary>
		/// This method updated the given ObjectMap instance with metadata obtained
		/// from the database.
		/// </summary>
		/// <param name="map">The ObjectMap to update</param>
		public virtual void UpdateObjectMap( ObjectMap map )
		{
			if( level != AnalyzerLevel.None )
			{
				TableMap dbMap = TableMaps[ map.TableName.ToLower() ] as TableMap;
				if( dbMap == null && level == AnalyzerLevel.OnDemand )
				{
					Analyze( map.TableName );
					dbMap = TableMaps[ map.TableName.ToLower() ] as TableMap;
				}
				Check.VerifyNotNull( dbMap, Error.UnknownTable, map.TableName, map.Type );
				// make sure table name is set
				map.Provider = provider;
				// transfer table information
				map.IsView = dbMap.IsView;
				bool isUseData = ! map.IsView;
				isUseData |= map.IsView && HasCapability( ColumnInformation.IsView );
				// transfer column information
				IList processedFields = new ArrayList( map.Fields.Count );
				foreach( FieldMap dbfm in dbMap.Fields )
				{
					try
					{
						FieldMap fm = map.Fields.FindColumn( dbfm.ColumnName );
						if( fm != null )
						{
							// view information
							if( map.IsView )
							{
								if( HasCapability( ColumnInformation.ViewType ) )
								{
									fm.SetDbType( dbfm.DbType );
								}
								if( HasCapability( ColumnInformation.ViewSize ) )
								{
									fm.SetSize( dbfm.Size );
								}
								if( HasCapability( ColumnInformation.ViewIsNullable ) )
								{
									fm.SetIsNullable( dbfm.IsNullable );
								}
								if( HasCapability( ColumnInformation.ViewIsPrimaryKey ) )
								{
									fm.SetIsPrimaryKey( dbfm.IsPrimaryKey );
								}
								if( HasCapability( ColumnInformation.ViewIsAutoGenerated ) )
								{
									fm.SetIsAutoGenerated( dbfm.IsAutoGenerated );
								}
								if( HasCapability( ColumnInformation.ViewIsForeignKey ) && dbfm.IsForeignKey )
								{
									fm.SetForeignKeyTableName( dbfm.ForeignKeyTableName );
									fm.SetForeignKeyColumnName( dbfm.ForeignKeyColumnName );
								}
							}
							else // table information
							{
								if( HasCapability( ColumnInformation.TableType ) )
								{
									fm.SetDbType( dbfm.DbType );
								}
								if( HasCapability( ColumnInformation.TableSize ) )
								{
									fm.SetSize( dbfm.Size );
								}
								if( HasCapability( ColumnInformation.TableIsNullable ) )
								{
									fm.SetIsNullable( dbfm.IsNullable );
								}
								if( HasCapability( ColumnInformation.TableIsPrimaryKey ) )
								{
									fm.SetIsPrimaryKey( dbfm.IsPrimaryKey );
								}
								if( HasCapability( ColumnInformation.TableIsAutoGenerated ) )
								{
									fm.SetIsAutoGenerated( dbfm.IsAutoGenerated );
								}
								if( HasCapability( ColumnInformation.TableIsForeignKey ) && dbfm.IsForeignKey )
								{
									fm.SetForeignKeyTableName( dbfm.ForeignKeyTableName );
									fm.SetForeignKeyColumnName( dbfm.ForeignKeyColumnName );
								}
							}
							// remember which fields have been processed (for error reporting later)
							processedFields.Add( fm );
						}
					}
					catch
					{
						// ignore the error but log a warning
						Check.LogWarning( LogCategories.Metadata,
						                  "Type {0} contains no mapping for column {1} in table {2}.",
						                  map.Type.Name, dbfm.ColumnName, map.TableName );
					}
				}
				// verify that all defined fields had an existing column in the target table
				if( isUseData && processedFields.Count < map.Fields.Count )
				{
					// construct informative error message
					StringBuilder sb = new StringBuilder();
					bool single = processedFields.Count == map.Fields.Count - 1;
					sb.AppendFormat( "The column{0} ", single ? "" : "s" );
					bool delimit = false;
					foreach( FieldMap fm in map.Fields )
					{
						if( ! processedFields.Contains( fm ) )
						{
							sb.AppendFormat( "{0}{1}", delimit ? ", " : "", fm.ColumnName );
							delimit = true;
						}
					}
					sb.AppendFormat( " in table {0} do{1} not exist.", map.TableName, single ? "es" : "" );
					// raise an exception
					Check.Fail( Error.DeveloperError, sb.ToString() );
				}
			}
		}
	}
}