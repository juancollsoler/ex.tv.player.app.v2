/*
 * PostgreSQL database schema analyzer
 * Copyright (C) 2004 Morten Mertner
 * 
 * This library is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU Lesser General Public License 2.1 or later, as
 * published by the Free Software Foundation. See the included License.txt
 * or http://www.gnu.org/copyleft/lesser.html for details.
 *
 * $Id: PostgreSQLAnalyzer.cs 1232 2008-03-14 05:36:00Z mm $
 */

using System;
using Gentle.Common;
using Gentle.Framework;

namespace Gentle.Provider.PostgreSQL
{
	public class PostgreSQLAnalyzer : GentleAnalyzer
	{
		public PostgreSQLAnalyzer( IGentleProvider provider ) : base( provider )
		{
		}

		public override ColumnInformation AnalyzerCapability
		{
			// ciBasic = ColumnInformation.Size | ColumnInformation.Type;
			// ciExtra = ColumnInformation.IsNullable | ColumnInformation.IsUnique;
			// ciKey = ColumnInformation.IsPrimaryKey | ColumnInformation.IsAutoGenerated;
			// ciRelationOut = ColumnInformation.IsForeignKey;
			// ciRelationIn = ColumnInformation.HasForeignKey;
			// ciLocal = ciBasic | ciExtra | ciKey | ciRelationOut;
			// ciAll = ciLocal | ciRelationIn;
			get { return ColumnInformation.ciBasic | ColumnInformation.ciExtra; }
		}

		/* List and UserRoles tables
		id    |          tablename          | type | columncount
        ------+-----------------------------+------+-------------
        31879 | List_listid_seq             | S    |           9
        31887 | List_pkey                   | i    |           1
        31881 | List                        | r    |           3
        31950 | UserRoles_pkey              | i    |           2
        31948 | UserRoles                   | r    |           2
		*/
		private const string selectTables = 
			// relkind decides table (r), index/primary key (i), sequence (S)
			"select oid as id, relname as tablename, relnatts as columncount " +
			"from pg_class where relkind in ('r','i','S','v') " +
			"and relname not like 'pg_%' and relname not like 'sql_%';";

		/* MemberPicture table
		field       | type  | typesize | fieldsize | notnull | hasdefault | default
		------------+-------+----------+-----------+---------+------------+---------
		picturedata | bytea |       -1 |        -1 | t       | f          |
		memberid    | int4  |        4 |        -1 | t       | f          |
		pictureid   | int4  |        4 |        -1 | t       | t          |
		*/
		private const string selectColumns =
			"select a.attname as field, t.typname as type, a.attlen as typesize, " +
			"a.atttypmod as fieldsize, a.attnotnull as notnull, " +
			"a.atthasdef as hasdefault, d.adsrc as default " +
			"from pg_attribute a " +
			"inner join pg_type t on a.atttypid = t.oid " +
			"inner join pg_class c on a.attrelid = c.oid " +
			"left join pg_attrdef d on c.oid = d.oid and a.attnum = d.adnum " +
			"where a.attnum > 0 and a.attisdropped = 'f' and " +
			"c.relname = '{0}';"; // table name

		/*
		
		*/
		private const string selectConstraints = 
			// relkind decides table (r), index/primary key (i), sequence (S)
			"select c.relname, c.relkind from pg_class c " +
			"inner join pg_constraint x on c.oid = x.conrelid " +
			"where c.relkind in ('r','i','S');";
		/*  // select primary keys.. example nicked from pg-cookbook; original looped through indkey[0-7]
			SELECT pg_attribute.attname 
			FROM pg_class, pg_attribute, pg_index 
			WHERE pg_class.relname = l_relname 
			AND pg_class.oid = pg_attribute.attrelid 
			AND pg_class.oid = pg_index.indrelid 
			AND pg_index.indkey[0] = pg_attribute.attnum 
			AND pg_index.indisprimary = ''t''
		*/

		/// <summary>
		/// Please refer to the <see cref="GentleAnalyzer"/> class and the <see cref="IDatabaseAnalyzer"/> 
		/// interface it implements a description of this method.
		/// </summary>
		public override void Analyze( string tableName )
		{
			try
			{
				bool isSingleRun = tableName != null;
				SqlStatement stmt = broker.GetStatement( selectTables );
				stmt.StatementType = StatementType.Select;
				SqlResult sr = stmt.Execute();
				for( int i = 0; i < sr.Rows.Count; i++ )
				{
					try
					{
						string dbTableName = sr.GetString( i, "tablename" ).Trim();
						if( ! isSingleRun || tableName.ToLower().Equals( dbTableName.ToLower() ) )
						{
							TableMap map = GetTableMap( dbTableName );
							if( map == null )
							{
								map = new TableMap( provider, dbTableName );
								maps[ dbTableName.ToLower() ] = map;
							}
							// get column information for this table
							GetColumnData( map );
							// abort loop if analyzing single table only
							if( isSingleRun )
							{
								break;
							}
						}
					}
					catch( GentleException fe )
					{
						// ignore errors caused by tables found in db but for which no map exists
						// TODO this should be a config option
						if( fe.Error != Error.NoObjectMapForTable )
						{
							throw fe;
						}
					}
				}
			}
			catch( Exception e )
			{
				Check.Fail( e, Error.Unspecified, "An error occurred while analyzing the database schema." );
			}
		}

		private void GetColumnData( TableMap map )
		{
			string sql = String.Format( selectColumns, map.TableName );
			SqlStatement stmt = broker.GetStatement( sql );
			stmt.StatementType = StatementType.Select;
			SqlResult sr = stmt.Execute();
			for( int i = 0; i < sr.Rows.Count; i++ )
			{
				// returns columns: Field, Type, TypeSize, FieldSize, NotNull, HasDefault, Default
				string columnName = sr.GetString( i, "field" );
				// get or create FieldMap for column
				FieldMap fm = map.GetFieldMapFromColumn( columnName );
				if( fm == null )
				{
					fm = new FieldMap( map, columnName );
					map.Fields.Add( fm );
				}
				bool isNullable = sr.GetString( i, "notnull" ).Trim().ToLower().StartsWith( "f" );
				if( fm != null )
				{
					bool hasDefault = sr.GetBoolean( i, "hasdefault" );
					fm.SetDbType( sr.GetString( i, "type" ), false );
					int size = ExtractSize( sr.GetInt( i, "typesize" ), sr.GetInt( i, "fieldsize" ) );
					fm.SetSize( size );
					fm.SetIsNullable( isNullable );
					//fm.SetIsPrimaryKey( sr.GetString( i, "Key" ).Equals( "PRI" ) );
					// fm.SetIsForeignKey( sr.GetString( i, "Key" ).Equals( "FOR" ) );
					//if( fm.IsPrimaryKey )
					//	fm.SetIsAutoGenerated( sr.GetString( i, "Key" ).Equals( "auto_increment" ) );
					//if( sr.GetString( i, "HasDefault" ).Equals( "t" ) )
					//	fm.SetMagicValue( sr.GetObject( i, "Default" ) );
				}
			}
		}

		private int ExtractSize( int typeSize, int fieldSize )
		{
			if( typeSize != -1 )
			{
				return typeSize;
			}
			if( fieldSize != -1 )
			{
				return fieldSize;
			}
			return 0;
		}
	}
}