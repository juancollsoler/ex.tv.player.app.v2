/*
 * Firebird database schema analyzer
 * Copyright (C) 2004 Carlos Guzmán Álvarez
 * 
 * This library is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU Lesser General Public License 2.1 or later, as
 * published by the Free Software Foundation. See the included License.txt
 * or http://www.gnu.org/copyleft/lesser.html for details.
 *
 * $Id: FirebirdAnalyzer.cs 1232 2008-03-14 05:36:00Z mm $
 */

using System;
using FirebirdSql.Data.FirebirdClient;
using Gentle.Common;
using Gentle.Framework;

namespace Gentle.Provider.Firebird
{
	/// <summary>
	/// This class is a caching database analyzer. When first created it will build a cache of
	/// all found tables and populate an ObjectMap with as much information as is available.
	/// </summary>
	public class FirebirdAnalyzer : GentleAnalyzer
	{
		public FirebirdAnalyzer( IGentleProvider provider ) : base( provider )
		{
		}

		public override ColumnInformation AnalyzerCapability
		{
			// ciBasic = ColumnInformation.Size | ColumnInformation.Type;
			// ciExtra = ColumnInformation.IsNullable | ColumnInformation.IsUnique;
			// ciKey = ColumnInformation.IsPrimaryKey | ColumnInformation.IsAutoGenerated;
			// ciRelationOut = ColumnInformation.IsForeignKey;
			// ciRelationIn = ColumnInformation.HasForeignKey;
			// ciLocal = ciBasic | ciExtra | ciKey | ciRelationOut;
			// ciAll = ciLocal | ciRelationIn;
			get { return ColumnInformation.ciLocal & ~ColumnInformation.IsAutoGenerated; }
		}

		private const string select =
			"SELECT " +
			"rfr.rdb$relation_name AS TableName, " +
			"rfr.rdb$field_name AS ColumnName, " +
			"rfr.rdb$field_position AS ColumnPosition, " +
			"fld.rdb$field_type AS ColumnDataType, " +
			"fld.rdb$field_sub_type AS ColumnSubType, " +
			"fld.rdb$field_length AS ColumnSize, " +
			"fld.rdb$field_precision AS ColumnPrecision, " +
			"fld.rdb$field_scale AS ColumnScale, " +
			"rfr.rdb$null_flag AS NullFlag, " +
			"fld.rdb$default_source AS DefaultValue, " +
			"(select count(*) from " +
			"rdb$relation_constraints rel, " +
			"rdb$indices idx, " +
			"rdb$index_segments seg " +
			"where " +
			"rel.rdb$constraint_type = 'PRIMARY KEY' " +
			"and rel.rdb$index_name = idx.rdb$index_name " +
			"and idx.rdb$index_name = seg.rdb$index_name " +
			"and rel.rdb$relation_name = rfr.rdb$relation_name " +
			"and seg.rdb$field_name = rfr.rdb$field_name) AS PrimaryKey, " +
			"(select count(*) from " +
			"rdb$relation_constraints rel, " +
			"rdb$indices idx, " +
			"rdb$index_segments seg " +
			"where " +
			"rel.rdb$constraint_type = 'FOREIGN KEY' " +
			"and rel.rdb$index_name = idx.rdb$index_name " +
			"and idx.rdb$index_name = seg.rdb$index_name " +
			"and rel.rdb$relation_name = rfr.rdb$relation_name " +
			"and seg.rdb$field_name = rfr.rdb$field_name) AS ForeignKey " +
			"FROM " +
			"rdb$relation_fields rfr " +
			"LEFT JOIN rdb$fields fld ON rfr.rdb$field_source = fld.rdb$field_name " +
			"LEFT JOIN rdb$relations rel ON (rfr.rdb$relation_name = rel.rdb$relation_name AND rel.rdb$system_flag IS NOT NULL) " +
			"ORDER BY " +
			"rfr.rdb$relation_name, rfr.rdb$field_position";

		private const string selectReferences =
			@"SELECT " +
			"pidx.rdb$relation_name AS FKTableName, " +
			"pseg.rdb$field_name AS FKColumnName, " +
			"rc.rdb$constraint_name AS FKName, " +
			"rc.rdb$relation_name AS PKTableName, " +
			"fseg.rdb$field_name AS PKColumnName, " +
			"fidx.rdb$foreign_key AS PKName " +
			"FROM " +
			"rdb$relation_constraints rc " +
			"inner join rdb$indices fidx ON (rc.rdb$index_name = fidx.rdb$index_name AND rc.rdb$constraint_type = 'FOREIGN KEY') " +
			"inner join rdb$index_segments fseg ON fidx.rdb$index_name = fseg.rdb$index_name " +
			"inner join rdb$indices pidx ON fidx.rdb$foreign_key = pidx.rdb$index_name " +
			"inner join rdb$index_segments pseg ON (pidx.rdb$index_name = pseg.rdb$index_name AND pseg.rdb$field_position=fseg.rdb$field_position) " +
			"where rc.rdb$relation_name = @TableName AND " +
			"fseg.rdb$field_name = @ColumnName";

		private static FbDbType GetFbDbType( int blrType, int subType, int scale )
		{
			switch( blrType )
			{
				case 37:
				case 38:
					return FbDbType.VarChar;

				case 14:
				case 15:
					return FbDbType.Char;

				case 40:
				case 41:
					return FbDbType.Text;

				case 7:
					if( scale < 0 )
					{
						return FbDbType.Decimal;
					}
					else
					{
						return FbDbType.SmallInt;
					}

				case 8:
					if( scale < 0 )
					{
						return FbDbType.Decimal;
					}
					else
					{
						return FbDbType.Integer;
					}

				case 9:
				case 16:
				case 45:
					if( scale < 0 )
					{
						return FbDbType.Decimal;
					}
					else
					{
						return FbDbType.BigInt;
					}

				case 27:
				case 11:
					return FbDbType.Double;

				case 10:
					return FbDbType.Float;

				case 12:
					return FbDbType.Date;

				case 13:
					return FbDbType.Time;

				case 35:
					return FbDbType.TimeStamp;

				case 261:
					if( subType == 1 )
					{
						return FbDbType.Text;
					}
					else
					{
						return FbDbType.Binary;
					}

				default:
					throw new GentleException( Error.UnsupportedColumnType, "Unsupported column data type." );
			}
		}

		public override void Analyze( string tableName )
		{
			GentleSqlFactory sf = provider.GetSqlFactory();
			try
			{
				bool isSingleRun = tableName != null;
				// Create foreign key statement
				SqlStatement fk = broker.GetStatement( StatementType.Select, selectReferences );
				sf.AddParameter( fk.Command, "TableName", (long) FbDbType.VarChar );
				sf.AddParameter( fk.Command, "ColumnName", (long) FbDbType.VarChar );
				// Get tables information
				SqlResult sr = broker.Execute( select );
				// process result set
				for( int i = 0; i < sr.Rows.Count; i++ )
				{
					try
					{
						string dbTableName = sr.GetString( i, "TableName" ).Trim();

						if( ! isSingleRun || tableName.ToLower().Equals( dbTableName.ToLower() ) )
						{
							TableMap map = GetTableMap( dbTableName );
							if( map == null )
							{
								map = new TableMap( provider, dbTableName );
								maps[ dbTableName.ToLower() ] = map;
							}

							// get column information for this table
							string columnName = sr.GetString( i, "ColumnName" ).Trim();
							FieldMap fm = map.GetFieldMapFromColumn( columnName );
							if( fm == null )
							{
								fm = new FieldMap( map, columnName );
								map.Fields.Add( fm );
							}
							FbDbType type = GetFbDbType(
								sr.GetInt( i, "ColumnDataType" ),
								sr[ i, "ColumnSubType" ] != null ? sr.GetInt( i, "ColumnSubType" ) : 0,
								sr[ i, "ColumnScale" ] != null ? sr.GetInt( i, "ColumnScale" ) : 0 );
							fm.SetDbType( (long) type );
							if( sr[ i, "NullFlag" ] == null )
							{
								fm.SetIsNullable( true );
							}
							else
							{
								fm.SetIsNullable( false );
							}
							if( sr[ i, "ColumnSize" ] != null )
							{
								switch( type )
								{
									case FbDbType.Binary:
									case FbDbType.Text:
										fm.SetSize( Int32.MaxValue );
										break;
									default:
										fm.SetSize( sr.GetInt( i, "ColumnSize" ) );
										break;
								}
							}
							if( sr.GetInt( i, "PrimaryKey" ) > 0 )
							{
								fm.SetIsPrimaryKey( true );
							}
							if( sr.GetInt( i, "ForeignKey" ) > 0 )
							{
								fk.SetParameter( "TableName", map.TableName.ToUpper() );
								fk.SetParameter( "ColumnName", columnName.ToUpper() );

								SqlResult res = fk.Execute();
								fm.SetForeignKeyTableName( res.GetString( 0, "FKTableName" ).Trim() );
								fm.SetForeignKeyColumnName( res.GetString( 0, "FKColumnName" ).Trim() );
							}
						}
					}
					catch( GentleException fe )
					{
						// ignore errors caused by tables found in db but for which no map exists
						// TODO this should be a config option
						if( fe.Error != Error.NoObjectMapForTable )
						{
							throw fe;
						}
					}
				}
			}
			catch( Exception e )
			{
				Check.Fail( e, Error.Unspecified, "An error occurred while analyzing the database schema." );
			}
		}
	}
}